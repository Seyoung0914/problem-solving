#include <iostream>

using namespace std;

/*
0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하라
근데 정수보다 당연히 K가 작긴 하겠지
만약에 같으면 뭐 같게 나오겠지
1+2, 2+1이 다른 경우래
2, 3 일 경우에는
1 1 1, 1 2, 2 1 이렇게 세가지 경우가 되겠죠? 그러니까 총 세가지 경우
2, 2 -> 1 1 끝.
2, 4
1 3, 2, 2, 3,1 끝.

20, 2 -> 21개
6 4 -> 84개

6을 4자리로?
->4(두자리) 2(두자리) * 2
->3(두자리) 3(두자리)
1 1 1 3, 1 1 3 1, 1 3 1 1, 3 1 1 1, 1 1 2 2, 1

숫자가 같은 경우는 당연히 1개고
숫자가 하나 더 작은 경우는
6 5 하나만 2니까 숫자만큼이 경우의 수 이고

1 0, 0 1- >1개
2, 1 0 ->1개
2, 2 -> 1개
3, 1 - > 1개
3, 3 -> 1개
3, 2 -> 2개 -> 1, 2, 2, 1 -> 1 1개, 2 1개, 21개, 1 1개
4, 1 -> 1개
4, 4 -> 1개
4, 2 -> 1 3, 3 1, 2 2 -> 3개
4, 3 -> 1 1 2, 1 2 1, 2 1 1 -> 3개
5, 2 -> 1 4, 2 3, 3 2, 4 1
5, 3 -> 1 1 3, 1 3 1, 3 1 1, 1 2 2, 2 1 2, 2 2 1 즉,

2개의 숫자를 더해서 4를 만드는 방법은
1개의 숫자로 c를 만들어 놓고 c와마지막 숫자 d를 더하면 된다.
0을 만들고 4를 더하면 된다
1을 만들고, 2를 만들고, 3을 만들고 4를 만들고

3개의 숫자를 더해서 6을 만드는 방법은
2개의 숫자로 0을
1을, 2를 3을, 4를, 5를, 6을 만들어 놓고 마지막 숫자를 더하면 된다.


*/

int main()
{
    long long dp[201][201] = {0};
    const int MOD = 1000000000;
    int N, K;

    cin >> N >> K;

    for (int i = 0; i <= N; i++)
        dp[1][i] = 1;

    for (int k = 1; k <= K; k++)
        dp[k][0] = 1;

    for (int k = 2; k <= K; k++)
    {
        for (int n = 1; n <= N; n++)
        {
            dp[k][n] = (dp[k - 1][n] + dp[k][n - 1]) % MOD;
        }
    }

    cout << dp[K][N] << endl;

    return 0;
}